# ðŸš€ Complete DSA Roadmap - From Zero to Hero

> A comprehensive guide to mastering Data Structures and Algorithms

---

## ðŸ“Š Progress Tracker

| Phase | Topics | Status |
|-------|--------|--------|
| Phase 1 | Basics & Fundamentals | â¬œ |
| Phase 2 | Data Structures | â¬œ |
| Phase 3 | Algorithms | â¬œ |
| Phase 4 | Advanced Topics | â¬œ |
| Phase 5 | Problem Solving Patterns | â¬œ |

---

## ðŸŽ¯ Phase 1: Fundamentals (Week 1-2)

### 1.1 Time & Space Complexity
- [ ] Big O Notation
- [ ] Big Omega (Î©) and Big Theta (Î˜)
- [ ] Best, Average, Worst Case Analysis
- [ ] Space Complexity Analysis
- [ ] Amortized Analysis

### 1.2 Mathematics for DSA
- [ ] Modular Arithmetic
- [ ] GCD & LCM (Euclidean Algorithm)
- [ ] Prime Numbers & Sieve of Eratosthenes
- [ ] Prime Factorization
- [ ] Combinatorics (nCr, nPr)
- [ ] Euler's Totient Function
- [ ] Fast Exponentiation
- [ ] Modular Inverse

### 1.3 Bit Manipulation
- [ ] Binary Number System
- [ ] Bitwise Operators (AND, OR, XOR, NOT, Shifts)
- [ ] Check/Set/Clear/Toggle ith bit
- [ ] Count Set Bits
- [ ] Power of 2 Check
- [ ] Single Number Problems
- [ ] Bit Masking

### 1.4 Recursion & Backtracking
- [ ] Recursion Basics
- [ ] Head vs Tail Recursion
- [ ] Recursion Tree & Stack
- [ ] Backtracking Concept
- [ ] N-Queens Problem
- [ ] Sudoku Solver
- [ ] Rat in Maze
- [ ] Permutations & Combinations
- [ ] Subset Generation

---

## ðŸ—ï¸ Phase 2: Data Structures (Week 3-6)

### 2.1 Arrays
- [ ] 1D Array Operations
- [ ] 2D Arrays (Matrix)
- [ ] Prefix Sum Array
- [ ] Difference Array
- [ ] Kadane's Algorithm
- [ ] Dutch National Flag
- [ ] Sliding Window on Arrays
- [ ] Two Pointer on Arrays

### 2.2 Strings
- [ ] String Basics & Operations
- [ ] Pattern Matching (Naive)
- [ ] KMP Algorithm
- [ ] Rabin-Karp Algorithm
- [ ] Z-Algorithm
- [ ] Manacher's Algorithm (Palindromes)
- [ ] Trie (Prefix Tree)
- [ ] Suffix Array (Advanced)

### 2.3 Linked List
- [ ] Singly Linked List
- [ ] Doubly Linked List
- [ ] Circular Linked List
- [ ] Floyd's Cycle Detection
- [ ] Reverse Linked List
- [ ] Merge Two Sorted Lists
- [ ] Find Middle Element
- [ ] Remove Nth Node from End

### 2.4 Stack
- [ ] Stack Implementation (Array/Linked List)
- [ ] Applications of Stack
- [ ] Infix/Prefix/Postfix Conversion
- [ ] Next Greater Element
- [ ] Next Smaller Element
- [ ] Stock Span Problem
- [ ] Largest Rectangle in Histogram
- [ ] Min Stack
- [ ] Monotonic Stack

### 2.5 Queue
- [ ] Queue Implementation
- [ ] Circular Queue
- [ ] Deque (Double Ended Queue)
- [ ] Priority Queue / Heap
- [ ] Sliding Window Maximum

### 2.6 Hashing
- [ ] Hash Table / Hash Map
- [ ] Hash Set
- [ ] Collision Handling (Chaining, Open Addressing)
- [ ] Frequency Counting
- [ ] Two Sum Problem
- [ ] Subarray with Given Sum
- [ ] Longest Consecutive Sequence

### 2.7 Trees
- [ ] Binary Tree Basics
- [ ] Tree Traversals (Inorder, Preorder, Postorder)
- [ ] Level Order Traversal
- [ ] Height/Depth of Tree
- [ ] Diameter of Tree
- [ ] Check Balanced Tree
- [ ] Lowest Common Ancestor (LCA)
- [ ] Binary Search Tree (BST)
- [ ] BST Operations (Insert, Delete, Search)
- [ ] Validate BST
- [ ] AVL Tree (Self-Balancing)
- [ ] Red-Black Tree (Concept)

### 2.8 Heap / Priority Queue
- [ ] Min Heap & Max Heap
- [ ] Heap Operations (Insert, Extract, Heapify)
- [ ] Build Heap from Array
- [ ] Heap Sort
- [ ] Kth Largest/Smallest Element
- [ ] Merge K Sorted Lists
- [ ] Top K Frequent Elements
- [ ] Median in Stream

### 2.9 Advanced Data Structures
- [ ] Trie (Prefix Tree)
- [ ] Segment Tree
- [ ] Segment Tree with Lazy Propagation
- [ ] Fenwick Tree (Binary Indexed Tree)
- [ ] Disjoint Set Union (DSU / Union-Find)
- [ ] Sparse Table (RMQ)

---

## âš¡ Phase 3: Algorithms (Week 7-12)

### 3.1 Sorting Algorithms
- [ ] Bubble Sort - O(nÂ²)
- [ ] Selection Sort - O(nÂ²)
- [ ] Insertion Sort - O(nÂ²)
- [ ] Merge Sort - O(n log n)
- [ ] Quick Sort - O(n log n)
- [ ] Heap Sort - O(n log n)
- [ ] Counting Sort - O(n + k)
- [ ] Radix Sort - O(d Ã— n)
- [ ] Bucket Sort - O(n)

### 3.2 Searching Algorithms
- [ ] Linear Search - O(n)
- [ ] Binary Search - O(log n)
- [ ] Lower Bound & Upper Bound
- [ ] Search in Rotated Sorted Array
- [ ] Peak Element
- [ ] Binary Search on Answer
- [ ] Ternary Search

### 3.3 Two Pointers Technique
- [ ] Two Sum (Sorted Array)
- [ ] Three Sum
- [ ] Container With Most Water
- [ ] Trapping Rain Water
- [ ] Remove Duplicates
- [ ] Merge Sorted Arrays
- [ ] Palindrome Check

### 3.4 Sliding Window
- [ ] Fixed Size Window
- [ ] Variable Size Window
- [ ] Maximum Sum Subarray of Size K
- [ ] Longest Substring Without Repeating
- [ ] Minimum Window Substring
- [ ] Longest Substring with K Distinct Characters

### 3.5 Divide and Conquer
- [ ] Merge Sort
- [ ] Quick Sort
- [ ] Binary Search
- [ ] Power Function
- [ ] Count Inversions
- [ ] Closest Pair of Points
- [ ] Karatsuba Multiplication

### 3.6 Greedy Algorithms
- [ ] Activity Selection
- [ ] Fractional Knapsack
- [ ] Job Sequencing
- [ ] Huffman Coding
- [ ] Minimum Platforms
- [ ] Coin Change (Greedy vs DP)
- [ ] Jump Game
- [ ] Gas Station

### 3.7 Dynamic Programming
#### 1D DP
- [ ] Fibonacci
- [ ] Climbing Stairs
- [ ] House Robber
- [ ] Maximum Subarray (Kadane's)
- [ ] Coin Change (Min Coins)
- [ ] Longest Increasing Subsequence (LIS)

#### 2D DP
- [ ] Longest Common Subsequence (LCS)
- [ ] Longest Common Substring
- [ ] Edit Distance
- [ ] 0/1 Knapsack
- [ ] Unbounded Knapsack
- [ ] Subset Sum
- [ ] Partition Equal Subset Sum
- [ ] Minimum Path Sum (Grid)
- [ ] Unique Paths

#### Interval DP
- [ ] Matrix Chain Multiplication
- [ ] Palindrome Partitioning
- [ ] Burst Balloons
- [ ] Optimal BST

#### DP on Trees
- [ ] Diameter of Tree
- [ ] Maximum Path Sum
- [ ] House Robber III

#### Bitmask DP
- [ ] Travelling Salesman Problem (TSP)
- [ ] Assignment Problem
- [ ] Counting Subsets

#### DP Patterns to Master
- [ ] Take / Not Take
- [ ] Infinite Supply
- [ ] DP on Subsequences
- [ ] DP on Strings
- [ ] DP on Grids
- [ ] DP with State Compression

---

## ðŸŒ Phase 4: Graph Algorithms (Week 13-16)

### 4.1 Graph Basics
- [ ] Graph Representation (Adjacency Matrix/List)
- [ ] Types of Graphs
- [ ] BFS (Breadth First Search)
- [ ] DFS (Depth First Search)
- [ ] Connected Components
- [ ] Cycle Detection (Directed & Undirected)
- [ ] Bipartite Graph Check
- [ ] Topological Sort (Kahn's & DFS)

### 4.2 Shortest Path Algorithms
- [ ] Dijkstra's Algorithm
- [ ] Bellman-Ford Algorithm
- [ ] Floyd-Warshall Algorithm
- [ ] 0-1 BFS
- [ ] Shortest Path in DAG
- [ ] A* Algorithm (Concept)

### 4.3 Minimum Spanning Tree
- [ ] Prim's Algorithm
- [ ] Kruskal's Algorithm
- [ ] DSU for Kruskal's

### 4.4 Advanced Graph
- [ ] Strongly Connected Components (Kosaraju's/Tarjan's)
- [ ] Bridges and Articulation Points
- [ ] Euler Path & Circuit
- [ ] Hamiltonian Path
- [ ] Network Flow (Ford-Fulkerson)
- [ ] Bipartite Matching

---

## ðŸŽ“ Phase 5: Advanced Topics (Week 17-20)

### 5.1 Advanced Trees
- [ ] Segment Tree with Lazy Propagation
- [ ] Persistent Segment Tree
- [ ] Merge Sort Tree
- [ ] Heavy Light Decomposition
- [ ] Centroid Decomposition
- [ ] LCA with Binary Lifting

### 5.2 Advanced Strings
- [ ] Suffix Array
- [ ] Suffix Tree
- [ ] Aho-Corasick Algorithm
- [ ] Suffix Automaton

### 5.3 Game Theory
- [ ] Nim Game
- [ ] Grundy Numbers
- [ ] Sprague-Grundy Theorem

### 5.4 Number Theory (Advanced)
- [ ] Chinese Remainder Theorem
- [ ] Miller-Rabin Primality Test
- [ ] Pollard's Rho Algorithm
- [ ] Lucas Theorem
- [ ] Extended Euclidean Algorithm
- [ ] Mobius Function

### 5.5 Geometry
- [ ] Line Intersection
- [ ] Convex Hull
- [ ] Polygon Area
- [ ] Point in Polygon
- [ ] Closest Pair of Points

---

## ðŸ§© Problem Solving Patterns

### Pattern 1: Frequency Counter
```
Use: Counting occurrences, anagrams, duplicates
DS: HashMap, Array
```

### Pattern 2: Two Pointers
```
Use: Sorted arrays, palindrome, pair sum
When: O(n) instead of O(nÂ²)
```

### Pattern 3: Sliding Window
```
Use: Contiguous subarrays/substrings
Types: Fixed size, Variable size
```

### Pattern 4: Fast & Slow Pointers
```
Use: Cycle detection, middle element
DS: Linked List, Arrays
```

### Pattern 5: Merge Intervals
```
Use: Overlapping intervals
Steps: Sort â†’ Merge
```

### Pattern 6: Cyclic Sort
```
Use: Numbers in range [1, n]
Pattern: Put number at its index
```

### Pattern 7: Binary Search Variants
```
Use: Search space reduction
Types: Lower/Upper bound, Search on answer
```

### Pattern 8: BFS/DFS
```
Use: Tree/Graph traversal, shortest path
BFS: Level-wise, Queue
DFS: Depth-wise, Stack/Recursion
```

### Pattern 9: Backtracking
```
Use: Generate all possibilities
Pattern: Choose â†’ Explore â†’ Unchoose
```

### Pattern 10: DP Patterns
```
1. Knapsack (0/1, Unbounded)
2. Fibonacci
3. LCS/LIS
4. Grid Paths
5. Partition
6. Bitmask
```

### Pattern 11: Monotonic Stack/Queue
```
Use: Next greater/smaller element
Pattern: Maintain sorted order in stack
```

### Pattern 12: Top K Elements
```
Use: K largest/smallest/frequent
DS: Heap, QuickSelect
```

---

## ðŸ“š Practice Resources

### Online Judges
- [ ] LeetCode (Start with Easy â†’ Medium â†’ Hard)
- [ ] Codeforces (Competitive Programming)
- [ ] AtCoder (Good for beginners)
- [ ] HackerRank (Topic-wise practice)
- [ ] GeeksforGeeks (Concept + Practice)
- [ ] CSES Problem Set (Must-do collection)

### Topic-wise Problem Count (Recommended)

| Topic | Easy | Medium | Hard | Total |
|-------|------|--------|------|-------|
| Arrays | 20 | 30 | 10 | 60 |
| Strings | 15 | 25 | 10 | 50 |
| Linked List | 10 | 15 | 5 | 30 |
| Stack/Queue | 10 | 20 | 5 | 35 |
| Trees | 15 | 30 | 10 | 55 |
| Graphs | 10 | 25 | 15 | 50 |
| DP | 15 | 40 | 20 | 75 |
| Binary Search | 10 | 20 | 5 | 35 |
| **Total** | **105** | **205** | **80** | **~400** |

---

## âœ… Weekly Study Plan

### Week Structure
```
Day 1-2: Learn concept + basic problems
Day 3-4: Medium difficulty problems
Day 5:   Hard problems + variations
Day 6:   Contest / Mixed practice
Day 7:   Review + weak areas
```

### Daily Routine
```
ðŸ“– 1 hour: Learn new concept
ðŸ’» 2 hours: Solve problems (3-5 problems)
ðŸ“ 30 min: Review and take notes
ðŸ”„ 30 min: Revise previous topics
```

---

## ðŸ† Milestones

- [ ] **Beginner**: Solve 100 Easy problems
- [ ] **Intermediate**: Solve 200 Medium problems
- [ ] **Advanced**: Solve 50 Hard problems
- [ ] **Contest Ready**: Solve 3 problems in 1.5 hours
- [ ] **Expert**: Rating 1800+ on Codeforces
- [ ] **Master**: Can solve most interview problems in 20-30 min

---

## ðŸ’¡ Tips for Success

1. **Consistency > Intensity**: 2 hours daily beats 14 hours on weekend
2. **Understand, Don't Memorize**: Know WHY an approach works
3. **Write Code by Hand**: Helps in interviews
4. **Time Yourself**: Practice under pressure
5. **Review Solutions**: Learn from others' approaches
6. **Maintain Notes**: Quick revision before interviews
7. **Teach Others**: Best way to solidify understanding
8. **Don't Skip Basics**: Strong foundation is key

---

## ðŸŽ¯ Interview Preparation Checklist

### Must-Know Topics
- [ ] Arrays & Strings
- [ ] Linked Lists
- [ ] Stacks & Queues
- [ ] Trees & BST
- [ ] Graphs (BFS, DFS, Dijkstra)
- [ ] Hash Tables
- [ ] Heaps
- [ ] Dynamic Programming
- [ ] Recursion & Backtracking
- [ ] Sorting & Searching

### Company-Specific Focus
| Company | Focus Areas |
|---------|-------------|
| Google | Graphs, DP, Arrays |
| Amazon | Trees, Graphs, OOP |
| Facebook | Arrays, Strings, Graphs |
| Microsoft | Trees, DP, Design |
| Apple | Arrays, Trees, System Design |

---

> **Remember**: The goal is not to memorize solutions, but to recognize patterns and apply the right technique. Happy Coding! ðŸš€

---

*Last Updated: February 2025*
*Created for: DSA Learning Repository*
